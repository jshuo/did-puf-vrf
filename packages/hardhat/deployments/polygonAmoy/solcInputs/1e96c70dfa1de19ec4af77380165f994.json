{
  "language": "Solidity",
  "sources": {
    "contracts/EthereumDIDRegistry.sol": {
      "content": "/* SPDX-License-Identifier: MIT */\n\npragma solidity ^0.8.6;\n\ncontract EthereumDIDRegistry {\n\tmapping(address => address) public owners;\n\tmapping(address => mapping(bytes32 => mapping(bytes32 => uint)))\n\t\tpublic delegates;\n\tmapping(address => uint) public changed;\n\tmapping(address => uint) public nonce;\n\n\tmodifier onlyOwner(address identity, address actor) {\n\t\trequire(actor == identityOwner(identity), \"bad_actor\");\n\t\t_;\n\t}\n\n\tevent DIDOwnerChanged(\n\t\taddress indexed identity,\n\t\taddress owner,\n\t\tuint previousChange\n\t);\n\n\tevent DIDDelegateChanged(\n\t\taddress indexed identity,\n\t\tbytes32 delegateType,\n\t\tbytes32 delegate,\n\t\tuint validTo,\n\t\tuint previousChange\n\t);\n\n\tevent DIDAttributeChanged(\n\t\taddress indexed identity,\n\t\tbytes32 name,\n\t\tbytes value,\n\t\tuint validTo,\n\t\tuint previousChange\n\t);\n\n\tfunction identityOwner(address identity) public view returns (address) {\n\t\taddress owner = owners[identity];\n\t\tif (owner != address(0x00)) {\n\t\t\treturn owner;\n\t\t}\n\t\treturn identity;\n\t}\n\n\tfunction checkSignature(\n\t\taddress identity,\n\t\tuint8 sigV,\n\t\tbytes32 sigR,\n\t\tbytes32 sigS,\n\t\tbytes32 hash\n\t) internal returns (address) {\n\t\taddress signer = ecrecover(hash, sigV, sigR, sigS);\n\t\trequire(signer == identityOwner(identity), \"bad_signature\");\n\t\tnonce[signer]++;\n\t\treturn signer;\n\t}\n\n\tfunction validDelegate(\n\t\taddress identity,\n\t\tbytes32 delegateType,\n\t\tbytes memory compressedPublicKey\n\t) public view returns (bool) {\n\t\tbytes32 publicKey;\n\t\tfor (uint i = 1; i <= 32; i++) {\n\t\t\tpublicKey |= bytes32(compressedPublicKey[i] & 0xFF) >> (i * 8);\n\t\t}\n\t\tuint validity = delegates[identity][\n\t\t\tkeccak256(abi.encode(delegateType))\n\t\t][publicKey];\n\t\treturn (validity > block.timestamp);\n\t}\n\n\tfunction changeOwner(\n\t\taddress identity,\n\t\taddress actor,\n\t\taddress newOwner\n\t) internal onlyOwner(identity, actor) {\n\t\towners[identity] = newOwner;\n\t\temit DIDOwnerChanged(identity, newOwner, changed[identity]);\n\t\tchanged[identity] = block.number;\n\t}\n\n\tfunction changeOwner(address identity, address newOwner) public {\n\t\tchangeOwner(identity, msg.sender, newOwner);\n\t}\n\n\tfunction changeOwnerSigned(\n\t\taddress identity,\n\t\tuint8 sigV,\n\t\tbytes32 sigR,\n\t\tbytes32 sigS,\n\t\taddress newOwner\n\t) public {\n\t\tbytes32 hash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\tbytes1(0x19),\n\t\t\t\tbytes1(0),\n\t\t\t\tthis,\n\t\t\t\tnonce[identityOwner(identity)],\n\t\t\t\tidentity,\n\t\t\t\t\"changeOwner\",\n\t\t\t\tnewOwner\n\t\t\t)\n\t\t);\n\t\tchangeOwner(\n\t\t\tidentity,\n\t\t\tcheckSignature(identity, sigV, sigR, sigS, hash),\n\t\t\tnewOwner\n\t\t);\n\t}\n\n\tfunction addDelegate(\n\t\taddress identity,\n\t\taddress actor,\n\t\tbytes32 delegateType,\n\t\tbytes memory compressedPublicKey,\n\t\tuint validity\n\t) internal onlyOwner(identity, actor) {\n\t\tbytes32 publicKey;\n\t\tfor (uint i = 1; i <= 32; i++) {\n\t\t\tpublicKey |= bytes32(compressedPublicKey[i] & 0xFF) >> (i * 8);\n\t\t}\n\t\tdelegates[identity][keccak256(abi.encode(delegateType))][publicKey] =\n\t\t\tblock.timestamp +\n\t\t\tvalidity;\n\t\temit DIDDelegateChanged(\n\t\t\tidentity,\n\t\t\tdelegateType,\n\t\t\tpublicKey,\n\t\t\tblock.timestamp + validity,\n\t\t\tchanged[identity]\n\t\t);\n\t\tchanged[identity] = block.number;\n\t}\n\n\tfunction addDelegate(\n\t\taddress identity,\n\t\tbytes32 delegateType,\n\t\tbytes memory publicKey,\n\t\tuint validity\n\t) public {\n\t\taddDelegate(identity, msg.sender, delegateType, publicKey, validity);\n\t}\n\n\tfunction revokeDelegate(\n\t\taddress identity,\n\t\taddress actor,\n\t\tbytes32 delegateType,\n\t\tbytes memory compressedPublicKey\n\t) internal onlyOwner(identity, actor) {\n\t\tbytes32 publicKey;\n\t\tfor (uint i = 1; i <= 32; i++) {\n\t\t\tpublicKey |= bytes32(compressedPublicKey[i] & 0xFF) >> (i * 8);\n\t\t}\n\t\tdelegates[identity][keccak256(abi.encode(delegateType))][\n\t\t\tpublicKey\n\t\t] = block.timestamp;\n\t\temit DIDDelegateChanged(\n\t\t\tidentity,\n\t\t\tdelegateType,\n\t\t\tpublicKey,\n\t\t\tblock.timestamp,\n\t\t\tchanged[identity]\n\t\t);\n\t\tchanged[identity] = block.number;\n\t}\n\n\tfunction revokeDelegate(\n\t\taddress identity,\n\t\tbytes32 delegateType,\n\t\tbytes memory compressedPublicKey\n\t) public {\n\t\trevokeDelegate(identity, msg.sender, delegateType, compressedPublicKey);\n\t}\n\n\t// function revokeDelegateSigned(address identity, uint8 sigV, bytes32 sigR, bytes32 sigS, bytes32 delegateType, address delegate) public {\n\t//   bytes32 hash = keccak256(abi.encodePacked(bytes1(0x19), bytes1(0), this, nonce[identityOwner(identity)], identity, \"revokeDelegate\", delegateType, delegate));\n\t//   revokeDelegate(identity, checkSignature(identity, sigV, sigR, sigS, hash), delegateType, delegate);\n\t// }\n\n\tfunction setAttribute(\n\t\taddress identity,\n\t\taddress actor,\n\t\tbytes32 name,\n\t\tbytes memory value,\n\t\tuint validity\n\t) internal onlyOwner(identity, actor) {\n\t\temit DIDAttributeChanged(\n\t\t\tidentity,\n\t\t\tname,\n\t\t\tvalue,\n\t\t\tblock.timestamp + validity,\n\t\t\tchanged[identity]\n\t\t);\n\t\tchanged[identity] = block.number;\n\t}\n\n\tfunction setAttribute(\n\t\taddress identity,\n\t\tbytes32 name,\n\t\tbytes memory value,\n\t\tuint validity\n\t) public {\n\t\tsetAttribute(identity, msg.sender, name, value, validity);\n\t}\n\n\tfunction setAttributeSigned(\n\t\taddress identity,\n\t\tuint8 sigV,\n\t\tbytes32 sigR,\n\t\tbytes32 sigS,\n\t\tbytes32 name,\n\t\tbytes memory value,\n\t\tuint validity\n\t) public {\n\t\tbytes32 hash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\tbytes1(0x19),\n\t\t\t\tbytes1(0),\n\t\t\t\tthis,\n\t\t\t\tnonce[identityOwner(identity)],\n\t\t\t\tidentity,\n\t\t\t\t\"setAttribute\",\n\t\t\t\tname,\n\t\t\t\tvalue,\n\t\t\t\tvalidity\n\t\t\t)\n\t\t);\n\t\tsetAttribute(\n\t\t\tidentity,\n\t\t\tcheckSignature(identity, sigV, sigR, sigS, hash),\n\t\t\tname,\n\t\t\tvalue,\n\t\t\tvalidity\n\t\t);\n\t}\n\n\tfunction revokeAttribute(\n\t\taddress identity,\n\t\taddress actor,\n\t\tbytes32 name,\n\t\tbytes memory value\n\t) internal onlyOwner(identity, actor) {\n\t\temit DIDAttributeChanged(identity, name, value, 0, changed[identity]);\n\t\tchanged[identity] = block.number;\n\t}\n\n\tfunction revokeAttribute(\n\t\taddress identity,\n\t\tbytes32 name,\n\t\tbytes memory value\n\t) public {\n\t\trevokeAttribute(identity, msg.sender, name, value);\n\t}\n\n\tfunction revokeAttributeSigned(\n\t\taddress identity,\n\t\tuint8 sigV,\n\t\tbytes32 sigR,\n\t\tbytes32 sigS,\n\t\tbytes32 name,\n\t\tbytes memory value\n\t) public {\n\t\tbytes32 hash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\tbytes1(0x19),\n\t\t\t\tbytes1(0),\n\t\t\t\tthis,\n\t\t\t\tnonce[identityOwner(identity)],\n\t\t\t\tidentity,\n\t\t\t\t\"revokeAttribute\",\n\t\t\t\tname,\n\t\t\t\tvalue\n\t\t\t)\n\t\t);\n\t\trevokeAttribute(\n\t\t\tidentity,\n\t\t\tcheckSignature(identity, sigV, sigR, sigS, hash),\n\t\t\tname,\n\t\t\tvalue\n\t\t);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}